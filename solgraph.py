"""
SolutionGraph Module

This module provides two main classes for analyzing and organizing mathematical (or any technical subject) solution steps:
1. SolutionGraph: Creates a directed acyclic graph (DAG) of solution steps using embeddings
2. SolutionTree: Creates a tree structure of solution steps using LLM-based similarity matching

Both classes are designed to help identify similar solution approaches, deduplicate solutions,
and visualize the relationships between different solution strategies for mathematical problems.

Since the LLM is notoriously bad at identifying errors correctly, we use a heuristic: steps on path to a correct solution are correct, other nodes generated by incorrect solutions should be wrong.

Similarly, for the DAG, where certain steps may not have a fixed order, we use another heuristic to save on LLM calls that are also extremely unreliable for this task: 
    We use each student's solution as a partial ordering, building SCCs to find steps that don't have a strict ordering policy. 
    We assume the immediately preceding and following steps outside of the SCC are the leading and trailing steps in solution flow

Dependencies:
- faiss: For efficient similarity search using vector embeddings
- numpy: For numerical operations and array handling
- apimanager: Custom API manager for LLM queries and text embeddings

Author: HackMIT 2025 Next 3W Team
"""

from faiss import IndexFlatL2
import numpy as np
from apimanager import APIManager
import os
import json

# --- Configuration loader ----------------------------------------------------
def _load_config() -> dict:
    cfg_path = os.path.abspath(os.path.join(os.path.dirname(__file__), "config.json"))
    try:
        with open(cfg_path, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return {}

_CONFIG = _load_config()
_STEP_SIZE = str(_CONFIG.get("step_size", "medium")).strip().lower()
_STEP_SIZE_GUIDANCE = {
    "small": (
        "Step size preference: small. Make steps granular; split on any nontrivial "
        "algebraic manipulation, substitution, or inference."
    ),
    "medium": (
        "Step size preference: medium. Group closely related moves; split when the "
        "approach changes or at key insights."
    ),
    "large": (
        "Step size preference: large. Prefer bigger, high-level steps; only split "
        "at major technique changes."
    ),
}
_STEP_GUIDANCE_TEXT = _STEP_SIZE_GUIDANCE.get(_STEP_SIZE, _STEP_SIZE_GUIDANCE["medium"])



class SolutionGraph:
    """
    A class that maintains a directed acyclic graph (DAG) of solution steps for exam problems.
    
    This class uses vector embeddings and LLM verification to identify similar solution steps
    across different submissions, creating a graph structure that shows the relationships
    between different approaches to solving the same problem.
    
    Key Features:
    - Semantic deduplication of solution steps using embeddings
    - LLM-based verification of step similarity
    - Graph generation with strongly connected components analysis
    - Solution correctness tracking and propagation
    """
    
    # Class constants for embedding and similarity search configuration
    EMBED_DIM = 3072  # Dimension of the embedding vectors (matches API embedding model)
    SEARCH_COUNT = 3  # Number of similar steps to retrieve during similarity search
    DISTANCE_THRESHOLD = 3072  # Maximum distance threshold for considering steps as similar
    api_manager = APIManager("bnxe")  # Shared API manager instance for all operations

    def __init__(self, problem_text, subject_domain="math"):
        """
        Initialize a new SolutionGraph for a specific problem.
        
        Args:
            problem_text (str): The text of the mathematical problem to be solved
            subject_domain (str): The subject domain (default: "math") used in LLM prompts
            
        Initializes:
            - FAISS indices for step and solution embeddings
            - Data structures for tracking solutions, steps, and correctness
            - Default start and end nodes for the solution graph
        """
        # Initialize FAISS indices for similarity search
        self.index = IndexFlatL2(SolutionGraph.EMBED_DIM)  # Index for individual solution steps
        self.solution_index = IndexFlatL2(SolutionGraph.EMBED_DIM)  # Index for complete solutions
        
        # Store the problem text and subject domain
        self.problem_text = problem_text
        self.subject_domain = subject_domain
        
        # Add dummy embeddings for start and end nodes (fixed reference points)
        self.index.add(
            np.array(
                [[100.0] * SolutionGraph.EMBED_DIM, [-100.0] * SolutionGraph.EMBED_DIM],
                dtype="float32",
            )
        )
        
        # Initialize data structures
        self.stepSummary = ["Read the problem statement", "Full Solution."]  # Summaries for each step
        self.solutions = []  # List of solutions, each as a list of step indices
        self.solution_is_correct = []  # Boolean flags for solution correctness
        self.solution_uid_to_index = {}  # Map solution UIDs to internal indices
        self.solution_texts = []  # Full text of each solution for deduplication
        self.step_root = [0, 1]  # Root mapping for step indices (starts with dummy nodes)

    def formatStepSummaryQuery(self, step):
        """
        Format a query to generate a concise summary of a solution step.
        
        Args:
            step (str): The solution step text to summarize
            
        Returns:
            list: Formatted query for the LLM API to generate a step summary
        """
        return [
            {
                "role": "system",
                "content": f"You are a helpful assistant who concisely and without unnecessary details summarizes the key ideas of the following step of a solution to a {self.subject_domain} problem.",
            },
            {"role": "user", "content": f"The step is as follows:\n{step}"},
        ]

    def formatVerificationQuery(self, step1, step2):
        """
        Format a query to verify if two solution steps are fundamentally the same.
        
        Args:
            step1 (str): First solution step to compare
            step2 (str): Second solution step to compare
            
        Returns:
            list: Formatted query for LLM to determine step equivalence (yes/no)
        """
        return [
            {
                "role": "system",
                "content": f"""Fundamentally, are these two steps of two different solutions to a {self.subject_domain} problem the same? They need to use the all of the exact same ideas, the same technique, and the same means of execution.

Don't overthink it! It should be obvious whether or not they're doing the same thing or not: Okay reasons are, say, \"Solution 1 uses length XY while solution 2 does not; no.\"

Return one word: \"yes\" or \"no\", nothing else. I forbid you from thinking too much or analyzing the solutions too much.""",
            },
            {
                "role": "user",
                "content": f"Solution 1:\n{step1}\n\nSolution 2:\n{step2}\n\nAnswer with yes or no only.",
            },
        ]

    def formatSolutionDedupeQuery(self, sol1, sol2):
        """
        Format a query to determine if two complete solutions are duplicates.
        
        Args:
            sol1 (str): First complete solution to compare
            sol2 (str): Second complete solution to compare
            
        Returns:
            list: Formatted query for LLM to determine solution equivalence (yes/no)
        """
        return [
            {
                "role": "system",
                "content": """Fundamentally, are these two solutions the same? They need to use the all of the exact same ideas, the same technique, and the same means of execution.

Don't overthink it! It should be obvious whether or not they're doing the same thing or not: Okay reasons are, say, \"Solution 1 uses length XY while solution 2 does not; no.\"

Return one word: \"yes\" or \"no\", nothing else. I forbid you from thinking too much or analyzing the solutions too much.""",
            },
            {
                "role": "user",
                "content": f"Solution 1:\n{sol1}\n\nSolution 2:\n{sol2}\n\nAnswer with yes or no only.",
            },
        ]

    def is_duplicate_solution(self, new_solution_text):
        """
        Check if a new solution is a duplicate of any existing solution.
        
        Uses semantic similarity search followed by LLM verification to determine
        if the new solution is fundamentally the same as any previously added solution.
        
        Args:
            new_solution_text (str): The complete text of the new solution to check
            
        Returns:
            tuple: (is_duplicate: bool, duplicate_index: int or None)
                - is_duplicate: True if solution is a duplicate
                - duplicate_index: Index of the duplicate solution if found, None otherwise
        """
        # Return immediately if no solutions have been indexed yet
        if self.solution_index.ntotal == 0:
            return (False, None)

        # Get embedding for the new solution
        emb = self.api_manager.embedText(new_solution_text)
        if emb is None:
            return (False, None)

        # Search for similar solutions using FAISS
        q = np.array([emb], dtype="float32")
        k = min(SolutionGraph.SEARCH_COUNT, self.solution_index.ntotal)
        D, I = self.solution_index.search(q, k)
        
        # Check each candidate for semantic equivalence using LLM
        for cand_idx in I[0]:
            cand_text = self.solution_texts[cand_idx]
            resp = SolutionGraph.api_manager.query(
                self.formatSolutionDedupeQuery(new_solution_text, cand_text)
            )
            if resp is None:
                continue
            ans = resp.strip().lower()
            if "yes" in ans:
                return (True, cand_idx)
        return (False, None)

    def getIndex(self, step):
        """
        Get or create an index for a solution step, with deduplication.
        
        This method performs the core step deduplication logic:
        1. Embed the step text
        2. Search for similar existing steps
        3. Use LLM verification to confirm semantic equivalence
        4. Either return existing step index or create new one
        
        Args:
            step (str): The solution step text to index
            
        Returns:
            int or None: Index of the step (existing or newly created), None if embedding fails
        """
        # Get embedding for the step
        embed = self.api_manager.embedText(step)
        if embed is None:
            return None
            
        # Search for similar steps in the existing index
        embed_vector = np.array([embed], dtype="float32")
        distance, indices = self.index.search(
            embed_vector, min(self.index.ntotal, SolutionGraph.SEARCH_COUNT)
        )
        
        # Add this step's embedding to the index 
        self.index.add(embed_vector)
        curi = int(self.index.ntotal - 1)  # Current step's index in FAISS
        self.step_root.append(curi)  # Initially maps to itself

        # Convert FAISS indices to step_root references
        for i in range(0, len(indices[0])):
            if indices[0][i] < len(self.step_root):
                indices[0][i] = self.step_root[indices[0][i]]

        # Check each similar step for semantic equivalence
        for i in range(0, len(indices[0])):
            if (
                i < len(distance[0])
                and distance[0][i] < SolutionGraph.DISTANCE_THRESHOLD
            ):
                # Use LLM to verify that the steps are semantically equivalent
                if indices[0][i] < len(self.stepSummary):
                    response = SolutionGraph.api_manager.query(
                        self.formatVerificationQuery(
                            step, self.stepSummary[indices[0][i]]
                        )
                    )
                    if response is None:
                        print("Failed to receive verification from API.")
                        continue
                    if response.strip().lower().startswith("y"):
                        # Steps are equivalent - map new step to existing one
                        ret = int(indices[0][i])
                        self.step_root[curi] = ret
                        return ret

        # No equivalent step found - create a new step summary
        summary = self.api_manager.query(self.formatStepSummaryQuery(step))
        if summary is None:
            return None
        self.stepSummary.append(summary.strip())
        return int(len(self.stepSummary) - 1)

    def addSolution(self, solution_uid, solution_text, is_correct):
        """
        Add a new solution to the graph, breaking it into steps and deduplicating.
        
        This is the main method for processing new solutions:
        1. Check for solution-level duplication
        2. Break solution into structured steps using LLM
        3. Index each step (with step-level deduplication)
        4. Track solution correctness and metadata
        
        Args:
            solution_uid (str): Unique identifier for this solution
            solution_text (str): Complete text of the solution
            is_correct (bool): Whether this solution is marked as correct
            
        Returns:
            bool: True if solution was successfully added, False otherwise
        """
        # First check if this entire solution is a duplicate
        is_dup, dup_idx = self.is_duplicate_solution(solution_text)
        if is_dup:
            # Map the new UID to the existing solution
            self.solution_uid_to_index[solution_uid] = dup_idx
            # Update correctness if this submission is correct and the existing one isn't
            if (
                is_correct
                and dup_idx < len(self.solution_is_correct)
                and not self.solution_is_correct[dup_idx]
            ):
                self.solution_is_correct[dup_idx] = True
            return True

        response = self.api_manager.query([
            {
                "role": "system",
                "content": (
                    "You are a solution explainer.\n\n"
                    + _STEP_GUIDANCE_TEXT
                    + "\n\nYour task is to take a complete solution and reformat it into structured steps. "
                      "Steps should be split before statements that change the course of the solution or "
                      "require a new idea. Do not add new reasoning or solve the problem yourself — just "
                      "restructure what is already there.\n\n"
                      "For each step:\n"
                      "- Give a short **title** (what technique/formula/idea is applied).\n"
                      "- If applicable, show the **general formula or theorem**.\n"
                      "- Summarize the **reasoning/work** for that step.\n"
                      "- Use inline LaTeX only (no block LaTeX).\n\n"
                      "At the end, include the **final result**.\n\n"
                      "Format it like this:\n\n"
                      "### Step 1. [Technique / Formula Name]\n"
                      "Formula: ...  \n"
                      "Reasoning: ...\n\n"
                      "### Step 2. [Technique / Formula Name]\n"
                      "Formula: ...  \n"
                      "Reasoning: ...\n\n"
                      "..."
                ),
            },
            {"role": "user", "content": solution_text},
        ])

        if response is None:
            print("Failed to receive step breakdown from API.")
            return False

        # Parse the structured steps and get indices for each
        steps = response.split("###")[1:]  # Split on step markers, skip first empty part
        stepIndices = []
        for step in steps:
            step = step.strip()
            if step:
                # Get or create index for this step (handles deduplication)
                ind = self.getIndex(step)
                if ind is None:
                    print(f"Failed to embed step: {step}. Solution will not be added.")
                    return False
                else:
                    stepIndices.append(ind)

        # Store the solution as a sequence of step indices
        self.solutions.append(stepIndices)
        self.solution_uid_to_index[solution_uid] = len(self.solutions) - 1
        self.solution_is_correct.append(is_correct)

        # Add the full solution text to the solution index for future deduplication
        emb = self.api_manager.embedText(solution_text)
        if emb is not None:
            self.solution_index.add(np.array([emb], dtype="float32"))
            self.solution_texts.append(solution_text)
        return True

    def generateGraph(self):
        """
        Generate a directed acyclic graph (DAG) representing the solution flow.
        
        This method creates a graph structure from all the added solutions by:
        1. Building edges between consecutive steps in each solution
        2. Finding strongly connected components using Kosaraju's algorithm
        3. Use condensed graph as a heuristic to determine best step connection order
        4. Marking step correctness based on correct solutions
        
        Returns:
            dict: A dictionary containing:
                - "graph": List of (from_node, to_node) tuples representing edges
                - "step_summary": List of step summary texts indexed by step ID
                - "step_is_correct": List of boolean values indicating step correctness
                - "submissions": List of submission data with UIDs and node sequences
        """
        # Initialize graph data structures
        graph = [[] for i in range(0, len(self.stepSummary))]  # Adjacency list representation
        inDegree = [0] * len(self.stepSummary)  # Track in-degrees for each node
        submissions = []  # Store submission metadata
        n = len(self.stepSummary)

        # Build directed edges between consecutive steps in each solution
        for i in range(0, len(self.solutions)):
            for j in range(0, len(self.solutions[i]) - 1):
                graph[self.solutions[i][j]].append(self.solutions[i][j + 1])
                inDegree[self.solutions[i][j + 1]] += 1

        # Extract strongly connected components using Kosaraju's algorithm
        sccs = self.kosaraju_scc(graph, n)
        scc_indices = [0 for i in range(0, n)]
        for scc_id in range(0, len(sccs)):
            for node in sccs[scc_id]:
                scc_indices[node] = scc_id

        # Build the step summary graph
        step_graph = []
        for solution in self.solutions:
            for j in range(0, len(solution)):
                found_prev = False
                found_next = False
                
                # Find the previous step that's in a different SCC
                for k in range(j - 1, -1, -1):
                    if scc_indices[solution[j]] != scc_indices[solution[k]]:
                        step_graph.append(
                            (int(solution[k]), int(solution[j]))
                        )  # Convert to Python int
                        found_prev = True
                        break
                for k in range(j + 1, len(solution)):
                    if scc_indices[solution[j]] != scc_indices[solution[k]]:
                        step_graph.append(
                            (int(solution[j]), int(solution[k]))
                        )  # Convert to Python int
                        found_next = True
                        break
                if not found_prev:
                    step_graph.append((0, int(solution[j])))  # Convert to Python int
                if not found_next:
                    step_graph.append((int(solution[j]), 1))  # Convert to Python int

        # Mark step correctness based on correct solutions
        # A step is considered correct if it appears in at least one correct solution
        step_is_correct = [False for i in range(0, n)]
        for i in range(0, len(self.solutions)):
            if self.solution_is_correct[i] is True:
                for step_idx in self.solutions[i]:
                    step_is_correct[step_idx] = True

        # Prepare submission data for visualization/analysis
        for uid, idx in self.solution_uid_to_index.items():
            submissions.append(
                {
                    "submission_uid": uid,
                    "submission_nodes": [0] + self.solutions[idx]+ [1]
                }
            )

        return {
            "graph": step_graph,
            "step_summary": self.stepSummary,
            "step_is_correct": step_is_correct,
            "submissions": submissions,
        }

    def kosaraju_scc(self, graph, n):
        """
        Kosaraju's algorithm to find strongly connected components (SCCs).
        
        This algorithm is used to identify cycles in the step graph and group
        steps that are mutually reachable (forming cycles). The algorithm works
        in two phases with DFS traversals.
        
        Args:
            graph (list): Adjacency list representation of the directed graph
            n (int): Number of nodes in the graph
            
        Returns:
            list: List of SCCs, where each SCC is a list of node indices that
                  are strongly connected (can reach each other)
        """
        # Phase 1: Create transpose graph (reverse all edge directions)
        transpose_graph = [[] for _ in range(n)]
        for u in range(n):
            for v in graph[u]:
                transpose_graph[v].append(u)  # Reverse edge u->v to v->u

        # Phase 2: First DFS on original graph to get finishing times
        visited = [False] * n
        stack = []  # Stack to store nodes in order of finishing times

        def dfs1(node):
            """First DFS: mark visited and push to stack when done with subtree"""
            visited[node] = True
            for neighbor in graph[node]:
                if not visited[neighbor]:
                    dfs1(neighbor)
            stack.append(node)  # Add to stack after visiting all descendants

        # Run DFS on all unvisited nodes to get complete finishing order
        for i in range(n):
            if not visited[i]:
                dfs1(i)

        # Phase 3: Second DFS on transpose graph in reverse finishing order
        visited = [False] * n
        sccs = []  # List to store all strongly connected components

        def dfs2(node, scc):
            visited[node] = True
            scc.append(node)
            for neighbor in transpose_graph[node]:
                if not visited[neighbor]:
                    dfs2(neighbor, scc)

        # Process nodes in reverse order of finish times
        while stack:
            node = stack.pop()
            if not visited[node]:
                scc = []
                dfs2(node, scc)
                sccs.append(scc)

        return sccs


class SolutionTree:
    """
    A tree-based representation of solution steps with hierarchical organization.
    
    Unlike SolutionGraph which uses embeddings for similarity, SolutionTree uses
    LLM-based matching to build a hierarchical tree where similar solution paths
    are merged at their common prefixes. This creates a tree structure showing
    how different solutions diverge from common starting points.
    
    Key Features:
    - Tree structure with nodes representing solution steps
    - LLM-based step matching and prefix finding
    - Correctness propagation up the tree
    - Dynamic tree restructuring when adding new solutions
    """
    
    class Node:
        """
        A node in the solution tree representing a step or partial solution.
        
        Each node can have multiple children (representing different ways to continue)
        and tracks whether any path through it leads to a correct solution.
        """
        
        def pull_correctness(self):
            """
            Propagate correctness from children up to this node.
            A node is correct if any of its children are correct.
            """
            if not self.is_correct:
                self.is_correct = any(child.is_correct for child in self.children)

        def __init__(self, step_text, creation_index):
            """
            Initialize a new tree node.
            
            Args:
                step_text (str): The solution text associated with this node
                creation_index (int): Unique identifier for this node
            """
            self.children = []  # List of child nodes
            self.parent = None  # Parent node (not currently used)
            self.is_correct = False  # Whether this node leads to correct solutions
            self.creation_index = creation_index  # Unique node identifier
            self.terminal = []  # List of solution indices that end at this node
            if step_text is not None:
                self.parent_summary = step_text  # Store the solution text

    api_manager = APIManager("bnxe")  # Shared API manager for LLM queries

    def __init__(self, problem_text, subject_domain="math"):
        """
        Initialize a new SolutionTree for organizing solution steps.
        
        Args:
            problem_text (str): The text of the mathematical problem
            subject_domain (str): Subject domain for LLM prompts (default: "math")
        """
        self.problem_text = problem_text
        self.subject_domain = subject_domain
        self.numNodes = 0  # Counter for assigning unique node IDs
        
        # Create root node representing the start of any solution
        self.root = self.Node("Read the problem", self.numNodes)
        self.numNodes += 1
        
        # Tracking structures for solutions
        self.solution_uid_to_index = {}  # Map solution UIDs to internal indices
        self.sol_count = 0  # Total number of solutions added

    def generateTree(self):
        """
        Generate a tree representation of all solutions for visualization/analysis.
        
        Traverses the tree structure and extracts:
        - Parent-child relationships (edges)
        - Node summaries and correctness information
        - Solution paths through the tree
        
        Returns:
            dict: Tree data containing:
                - "graph": List of (parent_id, child_id) edge tuples
                - "step_summaries": List of node summary texts by creation_index
                - "step_is_correct": List of correctness flags by creation_index  
                - "submissions": List of solution paths with UIDs and node sequences
        """
        # Initialize data structures for tree representation
        edges = []  # Parent-child relationships
        node_summaries = [""] * self.numNodes  # Text content for each node
        node_correctness = [False] * self.numNodes  # Correctness flags
        submissions = [{} for i in range(self.sol_count)]  # Solution path data
        stack = []  # Current path during DFS traversal

        def dfs(node):
            """Depth-first traversal to extract tree structure and paths"""
            stack.append(node.creation_index)
            
            # Store node summary text
            if hasattr(node, "parent_summary"):
                node_summaries[node.creation_index] = node.parent_summary
            else:
                node_summaries[node.creation_index] = "Beginning of Solution"

            

            # Record solution paths that terminate at this node
            if hasattr(node, "terminal") and node.terminal:
                for sol_idx in node.terminal:
                    submissions[sol_idx]["submission_nodes"] = stack.copy()

            # Process all children and record parent-child edges
            for child in node.children:
                edges.append((node.creation_index, child.creation_index))
                dfs(child)
            
            stack.pop()  # Backtrack

            node.pull_correctness()

            # Store correctness information
            node_correctness[node.creation_index] = node.is_correct

        # Start DFS traversal from root
        dfs(self.root)
        
        # Add solution UIDs to submission data
        for uid, idx in self.solution_uid_to_index.items():
            submissions[idx]["submission_uid"] = uid
            
        return {
            "graph": edges,
            "step_summaries": node_summaries,
            "step_is_correct": node_correctness,
            "submissions": submissions,
        }

    def addSolution(self, solution_uid, solution_text, is_correct):
        """
        Add a new solution to the tree, merging with existing paths where possible.
        
        This method implements a complex tree-building algorithm that:
        1. Traverses the tree to find the best matching path
        2. Uses LLM queries to find common prefixes between solutions
        3. Dynamically restructures the tree by splitting nodes when needed
        4. Tracks solution correctness and propagates it up the tree
        
        Args:
            solution_uid (str): Unique identifier for this solution
            solution_text (str): Complete text of the solution
            is_correct (bool): Whether this solution is marked as correct
            
        Returns:
            bool: True if solution was successfully added, False on error
        """
        cur_node = self.root  # Start at the root of the tree
        nodeList = []  # Track the path taken for correctness propagation
        
        # Navigate through the tree to find where this solution belongs
        while True:
            nodeList.append(cur_node)
            # Find most similar child node
            res = -1
            if len(cur_node.children) == 0:
                cur_node.children.append(self.Node(solution_text, self.numNodes))
                self.numNodes += 1
                cur_node = cur_node.children[0]
                break
                
            # Find the most similar child node using LLM matching
            if len(cur_node.children) > 0:
                # Build a query listing all possible child paths
                query_string = "Here is the numbered list of possible first steps:\n"
                for i in range(0, len(cur_node.children)):
                    query_string += (
                        "Category "
                        + str(i + 1)
                        + ": \n"
                        + cur_node.children[i].parent_summary
                        + "\n"
                    )

                query_string += "\n"
                query_string += (
                    "Match the following solution to one of the first steps:\n"
                    + solution_text
                    + "\n\n"
                )

                # Ask LLM to choose the best matching child
                response = SolutionTree.api_manager.query(
                    [
                        {
                            "role": "system",
                            "content": r"You will be provided 1) A numbered list of possible first steps to a math problem and 2) A solution to that math problem. Task: Find the first step that best matches the user's solution. Do not think too hard. Respond with only the number of the best match in the following format:\n ### [Index]",
                        },
                        {"role": "user", "content": query_string},
                    ]
                )
                if response is None:
                    print("Failed to receive response from API.")
                    return False
                    
                # Parse the LLM response to get the selected child index
                try:
                    parts = response.split("###")
                    if len(parts) < 2:
                        print("Invalid response format from API.")
                        return False
                    res = int(parts[1].strip()) - 1  # Convert to 0-based indexing
                    if res < 0:
                        res = 0
                    if res >= len(cur_node.children):
                        res = len(cur_node.children) - 1
                    if res < 0 or res >= len(cur_node.children):
                        print(
                            f"Invalid index {res+1} from API response. Must be between 1 and {len(cur_node.children)}."
                        )
                        return False
                except (ValueError, IndexError) as e:
                    print(f"Error parsing API response: {e}")
                    return False

            # Now find the shared prefix between the selected child and new solution
            shared = ""
            unshared1 = cur_node.children[res].parent_summary  # Remaining part of existing child
            unshared2 = solution_text  # Remaining part of new solution
            
            if res != -1:
                # Find the common prefix between the existing child and new solution
                shared = self.api_manager.query(
                    [
                        {
                            "role": "system",
                            "content": f"You will be given two solutions to a math problem. Task: Find the largest prefix of steps shared by both solutions, verifying equal intermediate values. Respond with only the shared prefix. If no such prefix exists, respond with an empty string and no other text.",
                        },
                        {
                            "role": "user",
                            "content": f"Solution 1:\n{cur_node.children[res].parent_summary}\nSolution 2:\n{solution_text}",
                        },
                    ]
                )
                if shared is None:
                    print("die")
                    return False
                    
                # Find the unshared part of the existing child solution
                unshared1 = self.api_manager.query(
                    [
                        {
                            "role": "system",
                            "content": f"You will be given a solution to a {self.subject_domain} problem, as well as an incomplete prefix of that solution. Task: Find the part of the complete solution not included in the incomplete prefix. Respond with only the unshared part. If no part exists, respond with an empty string.",
                        },
                        {
                            "role": "user",
                            "content": f"Full Solution:\n{cur_node.children[res].parent_summary}\nIncomplete Prefix:\n{shared}",
                        },
                    ]
                )
                if unshared1 is None:
                    print("die")
                    return False
                    
                # Find the unshared part of the new solution
                unshared2 = self.api_manager.query(
                    [
                        {
                            "role": "system",
                            "content": f"You will be given a solution to a {self.subject_domain} problem, as well as an incomplete prefix of that solution. Task: Find the part of the complete solution not included in the incomplete prefix. Respond with only the unshared part. If no part exists, respond with an empty string.",
                        },
                        {
                            "role": "user",
                            "content": f"Full Solution:\n{solution_text}\nIncomplete Prefix:\n{shared}",
                        },
                    ]
                )
                if unshared2 is None:
                    print("die")
                    return False
            # Clean up the text parts
            shared = shared.strip()
            unshared1 = unshared1.strip()
            unshared2 = unshared2.strip()
            
            # Handle tree restructuring based on what was shared vs. unshared
            if unshared1 != "":
                # The existing child has content beyond the shared prefix
                # Need to restructure the tree to accommodate both branches
                
                if shared != "":
                    # Create a new intermediate node for the shared prefix
                    cur_node.children.append(self.Node(shared, self.numNodes))
                    self.numNodes += 1
                    
                    # Move the existing child under the new shared node
                    cur_node.children[-1].children.append(cur_node.children[res])
                    cur_node.children[res].parent_summary = unshared1
                    
                    # Swap positions and remove the old reference
                    cur_node.children[-1], cur_node.children[res] = (
                        cur_node.children[res],
                        cur_node.children[-1],
                    )
                    cur_node.children.pop()
                    cur_node = cur_node.children[res]  # Move to the shared node
                    nodeList.append(cur_node)
                
                # Add the new solution as a sibling to the existing child
                cur_node.children.append(self.Node(unshared2, self.numNodes))
                self.numNodes += 1
                cur_node = cur_node.children[-1]  # Move to the new solution node
                break
            else:
                # The existing child is fully contained in the shared prefix
                # Continue traversing down this path with the remaining solution text
                solution_text = unshared2
                cur_node = cur_node.children[res]
                
            # If we've consumed the entire solution text, we're done
            if solution_text == "":
                break
        
        # Mark this node as a terminal point for the solution
        nodeList.append(cur_node)
        cur_node.terminal.append(self.sol_count)
        self.solution_uid_to_index[solution_uid] = self.sol_count
        
        # Propagate correctness up the tree if this solution is correct
        if is_correct:
            cur_node.is_correct = True
            for node in reversed(nodeList):
                node.pull_correctness()
                
        self.sol_count += 1
        return True
